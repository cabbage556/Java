# LSP - 리스코프 치환 원칙

> "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마틴

의역
> "하위 클래스의 인스턴스는 상위 타입 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다."

객체 지향의 상속은 두 조건을 만족해야 한다.
- **하위 클래스 is a kind of 상위 클래스** : 하위 클래스는 상위 클래스의 한 분류다.
- **구현 클래스 is able to 인터페이스** : 구현 클래스는 인터페이스할 수 있어야 한다.

이 두 조건을 만족한다면 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다.
- 만족하지 않는다면 상속이 계층도 형태로 구현된 경우

상속이 계층도로 구현된 잘못된 예시(리스코프 치환 원칙 위반)

```java
아버지 춘향이 = new 딸();
```
- 아버지 : 상위 클래스(기반 타입), 딸 : 하위 클래스(서브 타입)
- 춘향이는 아버지 타입 객체 참조 변수이므로 춘향이가 아버지 객체의 행위를 할 수 있어야 함
- 이 점은 논리적으로 이상하므로 올바른 상속이 아님

**상속이 계층도/조직도 형태로 구현된 경우 리스코프 치환 원칙은 만족하지 않는다.**

상속이 분류도로 구현된 올바른 예시(리스코프 치환 원칙 만족)

```java
동물 뽀로로 = new 펭귄();
```
- 동물 : 상위 클래스(기반 타입), 펭귄 : 하위 클래스(서브 타입)
- 뽀로로는 동물 타입 객체 참조 변수이므로 뽀로로가 동물 객체의 행위를 할 수 있음
- 이 점은 논리적으로 이상하지 않으므로 올바른 상속임

**상속이 분류도 형태로 구현된 경우 리스코프 치환 원칙은 만족한다.**

리스코프 치환 원칙은 객체 지향의 상속을 올바르게 활용하면 자연스럽게 얻을 수 있다.
- 객체 지향의 상속의 두 조건을 잘 생각하자.
- 객체 지향의 상속은 **분류도**로 구현해야 한다.

리스코프 치환 원칙에 따라 상위 클래스는 풍부할수록 좋다.
- `poorSuperClass` 패키지의, `richSuperClass` 패키지의 `Driver` 클래스 비교
